## 计算机网络

### 1在地址栏里输入一个URL,到这个页面呈现出来，中间会发生什么？

DNS解析

TCP连接

发送HTTP请求

服务器处理请求并返回HTTP报文

浏览器解析渲染页面

连接结束

详细：

1、判断是否有强缓存可以直接读取

2、查找ip(缓存（浏览器缓存》系统缓存》路由器缓存）-》没找到，系统中的hosts文件中的记录》DNS服务器)-》

3、封装TCP，IP+port构造http请求-》将http请求（请求方法，请求说明，请求附带数据）封装在TCP包中，TCP三次握手建立来连接

4、TCP传输，TCP传输层》网络层》数据链路层》物理层到达服务器，

5、 HTTP 连接，发送请求方法，请求头，请求附带数据

6、服务器响应，服务器解析请求作出响应，返回相应HTML给浏览器

7、浏览器构建DOM树，DOM树构建中如果遇到JS和外部JS，会停下来执行或下载代码，（阻塞，所以一般js放在最后）

8、根据外部样式，内部样式，内联样式构建CSSOM树，

9、将CSSOM与DOM树合并为渲染树（排除非视觉节点，display：none的节点，Script标签等）

10、进行布局，布局主要确定元素位置尺寸，渲染页面，加载资源（图片，音视频都进行并行下载）一般采用Cache-Control，在请求这些有设置了缓存的数据时，会先查看是否过期，如果没有过期则直接使用本地缓存，过期则请求并在服务器校验文件是否修改，如果上一次响应设置了ETag值会在这次请求的时候作为If-None-Match的值交给服务器校验，如果一致，继续校验 Last-Modified，没有设置ETag则直接验证Last-Modified，再决定是否返回304

输入url后，首先需要找到这个url域名的服务器ip,为了寻找这个ip，浏览器首先会寻找缓存，查看缓存中是否有记录，缓存的查找记录为：浏览器缓存-》系统缓存-》路由器缓存，缓存中没有则查找系统的hosts文件中是否有记录，如果没有则查询DNS服务器，得到服务器的ip地址后，浏览器根据这个ip以及相应的端口号，构造一个http请求，这个请求报文会包括这次请求的信息，主要是请求方法，请求说明和请求附带的数据，并将这个http请求封装在一个tcp包中，这个tcp包会依次经过传输层，网络层，数据链路层，物理层到达服务器，服务器解析这个请求来作出响应，返回相应的html给浏览器，因为html是一个树形结构，浏览器根据这个html来构建DOM树，在dom树的构建过程中如果遇到JS脚本和外部JS连接，则会停止构建DOM树来执行和下载相应的代码，这会造成阻塞，这就是为什么推荐JS代码应该放在html代码的后面，之后根据外部样式，内部样式，内联样式构建一个CSS对象模型树CSSOM树，构建完成后和DOM树合并为渲染树，这里主要做的是排除非视觉节点，比如script，meta标签和排除display为none的节点，之后进行布局，布局主要是确定各个元素的位置和尺寸，之后是渲染页面，因为html文件中会含有图片，视频，音频等资源，在解析DOM的过程中，遇到这些都会进行并行下载，浏览器对每个域的并行下载数量有一定的限制，一般是4-6个，当然在这些所有的请求中我们还需要关注的就是缓存，缓存一般通过Cache-Control、Last-Modify、Expires等首部字段控制。 Cache-Control和Expires的区别在于Cache-Control使用相对时间，Expires使用的是基于服务器 端的绝对时间，因为存在时差问题，一般采用Cache-Control，在请求这些有设置了缓存的数据时，会先 查看是否过期，如果没有过期则直接使用本地缓存，过期则请求并在服务器校验文件是否修改，如果上一次 响应设置了ETag值会在这次请求的时候作为If-None-Match的值交给服务器校验，如果一致，继续校验 Last-Modified，没有设置ETag则直接验证Last-Modified，再决定是否返回304

### 2.http1.0和http2.0的区别

http1.0采用文本传输，而http2.0采用的是二进制流传输，二进制流解析更高效。

http2.0使用了头部压缩和多路复用，多路复用代替了原有的序列和堵塞机制，同一个域名的所有请求都用同一个TCP连接完成，消除因需要建立多个TCP连接造成的网络延时和内存。之所以能够多路复用：并行多个流，即多个请求，对端通过帧中的标识区分不同的请求

 http2.0启用了头部压缩，HPACK 压缩格式对传输的 header 进行编码，减少了 header 的大小。并在两端维护了索引表，用于记录出现过的 header ，后面在传输过程中就可以传输已经记录过的 header 的键名

服务器推送：

流量控制：不同于HTTP/1.1,只要客户端可以处理，服务端就会尽可能快的发送数据，HTTP/2提供了客户端调整传输速度的能力（服务端也可以）。WINDOW_UPDATE帧用来完成这件事情，每个帧告诉对方，发送方想要接收多少字节，它将发送一个WINDOW_UPDATE帧以指示其更新后的处理字节能力。

设置优先级和资源数据的依赖关系。HTTP/2通过流的依赖可以实现这些功能。通过HEADERS帧和PRIORITY帧，客户端可以明确的告诉服务端它最需要什么，这是通过声明**依赖关系**和**权重**实现的。

### 3.多路复用的实现原理

二进制帧的设计，帧中前9个字节对于每个帧都是一致的，“服务器”解析HTTP/2的数据帧时只需要解析这些字节，就能准确的知道整个帧期望多少字节数来进行处理信息，type定义10种帧类型，表示头部，数据等等

![image-20200817233709679](E:\前端复习\前端知识点\wyFrontEndKnowledge\image\image-20200817233709679.png)

### 4、TCP三次握手四次挥手

SYN=1,ACK =1 ,seq=X,

 SYN=1,ack=x+1,seq=y,ACK=1

SYN=1,seq=x+1(如何携带数据),ack=y+1,

不是两次，

cookie有哪些字段：key ,value ,path,domain,httpOnly,expires/max-age,cache-controls,secure,samesite,,size